//
// Created by Hannah Hatch on 8/12/16.
//
#ifdef VC_USE_VCGLIB

#include "meshing/QuadricEdgeCollapseDecimation.h"

using namespace volcart::meshing;

QuadricEdgeCollapseDecimation::QuadricEdgeCollapseDecimation() {
    itkInput_ = nullptr;
    setDefaultParams();
}

QuadricEdgeCollapseDecimation::QuadricEdgeCollapseDecimation(VC_MeshType::Pointer mesh) {
    itkInput_ = mesh;
    setDefaultParams();
}

void QuadricEdgeCollapseDecimation::setMesh(VC_MeshType::Pointer mesh) {
    itkInput_ = mesh;
}

void QuadricEdgeCollapseDecimation::setDefaultParams(){
    collapseParams_.SetDefaultParams();
    collapseParams_.PreserveBoundary = true;
    collapseParams_.PreserveTopology = true;

}

///// Processing /////
void QuadricEdgeCollapseDecimation::compute() {
    _convertMeshtoVCG();
    vcg::LocalOptimization<VcgMesh> deciSession(vcgInput_, &collapseParams_);

    //Sets the target number of faces
    deciSession.SetTargetSimplices(desiredFaces_);
    deciSession.Init<VcgTriEdgeCollapse>();

    //Loop for large meshes that it can't decimate in one iteration
    while(vcgInput_.fn > desiredFaces_ && deciSession.DoOptimization())
    {
        std::cerr << "Current mesh is " << vcgInput_.fn << std::endl;
    }
    //Cleans up pointers generated by the edge collapse
    deciSession.Finalize<VcgTriEdgeCollapse>();
}

void QuadricEdgeCollapseDecimation::compute(size_t desiredFaces)
{
    desiredFaces_ = desiredFaces;
    compute();
}

///// Get Output /////
VC_MeshType::Pointer QuadricEdgeCollapseDecimation::getMesh(){
    outputMesh_ =  VC_MeshType::New();
    VC_PointType point;
    unsigned long j = 0;
    VcgMesh::VertexPointer vp;

    //Used to give the vertices an id that can be used to create faces
    vcg::SimpleTempData<VcgMesh::VertContainer , unsigned long> indices(vcgInput_.vert);

    //Takes vcg vertices and stores their coordinates into an itk point and adds it to itk mesh
    for(auto vi = vcgInput_.vert.begin(); vi!=vcgInput_.vert.end(); vi++){
        vp=&(*vi);
        indices[vp] = j;
        if(!vi->IsD()){
               point[0] = vi->P()[0];
               point[1] = vi->P()[1];
               point[2] = vi->P()[2];

            outputMesh_->SetPoint(j, point);
            j++;
           }
    }

    //Takes vcg cells and store their vertices into and itk cell and adds it to itk mesh
    unsigned long cellCnt = 0;
    VC_CellType::CellAutoPointer newCell;
    for(auto fi = vcgInput_.face.begin(); fi!=vcgInput_.face.end(); fi++){
        if(!fi->IsD())
        {   newCell.TakeOwnership(new VC_TriangleType);

            unsigned long point1 = indices[fi->V(0)];
            unsigned long point2 = indices[fi->V(1)];
            unsigned long point3 = indices[fi->V(2)];


            newCell->SetPointId(0, point1);
            newCell->SetPointId(1, point2);
            newCell->SetPointId(2, point3);

            outputMesh_->SetCell(cellCnt, newCell);
            cellCnt++;
        }

    }
    return outputMesh_;
}

void QuadricEdgeCollapseDecimation::_convertMeshtoVCG() {
    VcgMesh::FaceIterator fi = vcg::tri::Allocator<VcgMesh>::AddFaces(vcgInput_,itkInput_.GetPointer()->GetNumberOfCells());
    unsigned long counter = 0;

    //Takes itk points, gets their coordinates and adds a point to the vcg mesh
    for(auto pointsIterator = itkInput_->GetPoints()->Begin(); pointsIterator!=itkInput_->GetPoints()->End(); pointsIterator++, counter++)
    {
        vcg::tri::Allocator<VcgMesh>::AddVertex(vcgInput_,VcgMesh::CoordType(pointsIterator.Value()[0], pointsIterator.Value()[1], pointsIterator.Value()[2]));
    }

    //Iterates over the cells in the itk mesh and the points within those cells to create cells for the vcg mesh
    for(VC_CellIterator cellIterator = itkInput_->GetCells()->Begin(); cellIterator != itkInput_->GetCells()->End(); cellIterator++)
    {
        int i = 0;
        VcgMesh::VertexPointer ivp[3];
        for(auto p_id = cellIterator.Value()->PointIdsBegin(); p_id != cellIterator.Value()->PointIdsEnd(); p_id++, i++)
        {
            ivp[i] = &(vcgInput_.vert[*p_id]);

        }
        fi->V(0)=ivp[0];
        fi->V(1)=ivp[1];
        fi->V(2)=ivp[2];

        fi++;
    }
}
#endif