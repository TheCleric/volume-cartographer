//
// Created by Hannah Hatch on 8/12/16.
//

#include "meshing/QuadricEdgeCollapseResampling.h"


using namespace volcart::meshing;


        QuadricEdgeCollapseResampling::QuadricEdgeCollapseResampling() {
            _itkInput = nullptr;
            setDefaultParams();
        }

        QuadricEdgeCollapseResampling::QuadricEdgeCollapseResampling(VC_MeshType::Pointer mesh) {
            _itkInput = mesh;
            setDefaultParams();
        }

        void QuadricEdgeCollapseResampling::setMesh(VC_MeshType::Pointer mesh) {
            _itkInput = mesh;
        }

        void QuadricEdgeCollapseResampling::setDefaultParams(){
            _collapseParams.SetDefaultParams();
            _collapseParams.PreserveBoundary = true;
            _collapseParams.PreserveTopology = true;

        }


        void QuadricEdgeCollapseResampling::compute(int iterations) {
           
            _convertMeshtoVCG();
            vcg::LocalOptimization<vcgMesh> deciSession(_vcgInput, &_collapseParams);

            //Sets the target number of faces
            deciSession.SetTargetSimplices(iterations);
            deciSession.Init<vcgTriEdgeCollapse>();

            //Loop for large meshes that it can't decimate in one iteration
            while(_vcgInput.fn > iterations && deciSession.DoOptimization())
            {
                std::cerr << "Current mesh is " << _vcgInput.fn << std::endl;
            }
            //Cleans up pointers generated by the edge collapse
            deciSession.Finalize<vcgTriEdgeCollapse>();
        }

        VC_MeshType::Pointer QuadricEdgeCollapseResampling::getMesh(){
            _outputMesh =  VC_MeshType::New();
            VC_PointType point;
            unsigned long j = 0;
            vcgMesh::VertexPointer vp;

            //Used to give the vertices an id that can be used to create faces
            vcg::SimpleTempData<vcgMesh::VertContainer , unsigned long> indices(_vcgInput.vert);

            //Takes vcg vertices and stores their coordinates into an itk point and adds it to itk mesh
            for(auto vi = _vcgInput.vert.begin(); vi!=_vcgInput.vert.end(); vi++){
                vp=&(*vi);
                indices[vp] = j;
                if(!vi->IsD()){
                       point[0] = vi->P()[0];
                       point[1] = vi->P()[1];
                       point[2] = vi->P()[2];

                    _outputMesh->SetPoint(j, point);
                    j++;
                   }
            }

            //Takes vcg cells and store their vertices into and itk cell and adds it to itk mesh
            unsigned long cellCnt = 0;
            VC_CellType::CellAutoPointer newCell;
            for(auto fi = _vcgInput.face.begin(); fi!=_vcgInput.face.end(); fi++){
                if(!fi->IsD())
                {   newCell.TakeOwnership(new VC_TriangleType);

                    unsigned long point1 = indices[fi->V(0)];
                    unsigned long point2 = indices[fi->V(1)];
                    unsigned long point3 = indices[fi->V(2)];


                    newCell->SetPointId(0, point1);
                    newCell->SetPointId(1, point2);
                    newCell->SetPointId(2, point3);

                    _outputMesh->SetCell(cellCnt, newCell);
                    cellCnt++;
                }

            }
            return _outputMesh;
        }
        
        void QuadricEdgeCollapseResampling::_convertMeshtoVCG() {
            vcgMesh::FaceIterator fi = vcg::tri::Allocator<vcgMesh>::AddFaces(_vcgInput,_itkInput.GetPointer()->GetNumberOfCells());
            unsigned long counter = 0;

            //Takes itk points, gets their coordinates and adds a point to the vcg mesh
            for(auto pointsIterator = _itkInput->GetPoints()->Begin(); pointsIterator!=_itkInput->GetPoints()->End(); pointsIterator++, counter++)
            {
                vcg::tri::Allocator<vcgMesh>::AddVertex(_vcgInput,vcgMesh::CoordType(pointsIterator.Value()[0], pointsIterator.Value()[1], pointsIterator.Value()[2]));
            }

            //Iterates over the cells in the itk mesh and the points within those cells to create cells for the vcg mesh
            for(VC_CellIterator cellIterator = _itkInput->GetCells()->Begin(); cellIterator != _itkInput->GetCells()->End(); cellIterator++)
            {
                int i = 0;
                vcgMesh::VertexPointer ivp[3];
                for(auto p_id = cellIterator.Value()->PointIdsBegin(); p_id != cellIterator.Value()->PointIdsEnd(); p_id++, i++)
                {
                    ivp[i] = &(_vcgInput.vert[*p_id]);

                }
                fi->V(0)=ivp[0];
                fi->V(1)=ivp[1];
                fi->V(2)=ivp[2];

                fi++;
            }
        }
