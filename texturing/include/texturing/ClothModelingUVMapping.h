// Cloth-modelling parameterization
// Created by Seth Parker on 3/14/16.

//   This algorithm treats 3D->2D parameterization as a cloth modeling/softbody
//   dynamics problem. The mesh being
// flattened can be thought of as a "wrinkled sheet" in 3D space. First, two
// corners of this "sheet" are pinned in place
// and the rest of the "sheet" is allowed to unfurl relative to these points.
// Second, this "sheet" is then dropped on a
// collision plane, which helps to smooth out many of the largely curved
// sections. Third, the boundary of the "sheet" is
// stretched "outward" and then allowed to relax to a resting position that
// minimizes the error in the surface area of
// the sheet.
//   The results of this method are highly dependent on the input mesh and the
//   large number of parameters that can be
// tweaked. I don't think there's much use for this class as is, but I'm leaving
// it here for reference. The general
// Bullet physics framework will be useful for improving the results of
// parameterizations generated by other methods.
#pragma once

#ifdef VC_USE_BULLET

#include <cmath>
#include <iostream>

#include <BulletSoftBody/btSoftBody.h>
#include <BulletSoftBody/btSoftBodyRigidBodyCollisionConfiguration.h>
#include <BulletSoftBody/btSoftRigidDynamicsWorld.h>
#include <btBulletDynamicsCommon.h>

#include "core/types/UVMap.h"
#include "core/vc_defines.h"

namespace volcart
{
namespace texturing
{
// Pretick callbacks
static void constrainMotionCallback(btDynamicsWorld* world, btScalar timeStep);
static void axisLockCallback(btDynamicsWorld* world, btScalar timeStep);
static void moveTowardTargetCallback(btDynamicsWorld* world, btScalar timeStep);
static void emptyPreTickCallback(btDynamicsWorld* world, btScalar timeStep);

class ClothModelingUVMapping
{
public:
    using PinIDs = std::vector<uint64_t>;
    enum Stage { Unfurl, Collision, Expansion };

    struct Pin {
        uint64_t index;
        btSoftBody::Node* node;
        btVector3 target;
    };

    ClothModelingUVMapping(
        ITKMesh::Pointer input,
        uint16_t unfurlIterations,
        uint16_t collideIterations,
        uint16_t expandIterations,
        PinIDs unfurlPins,
        PinIDs expansionPins);
    ~ClothModelingUVMapping();

    // Run the simulation all at once or in stages
    void run();
    void unfurl();
    void collide();
    void expand();

    // Parameters
    void setAcceleration(Stage s, double a);

    // Output
    ITKMesh::Pointer getMesh();
    volcart::UVMap getUVMap();

    // Callback functionality
    void _constrainMotion(btScalar timeStep);
    void _axisLock(btScalar timeStep);
    void _moveTowardTarget(btScalar timeStep);
    void _emptyPreTick(btScalar timeStep);

private:
    // Softbody
    const ITKMesh::Pointer mesh_;
    btSoftBody* softBody_;
    double meshToWorldScale_;
    std::vector<Pin> currentPins_;

    // Collision Plane
    btRigidBody* collisionPlane_;

    // Simulation
    uint16_t unfurlIterations_;
    double unfurlA_;
    PinIDs unfurlPins_;
    void unfurl_();

    uint16_t collideIterations_;
    double collisionA_;
    void collide_();

    uint16_t expandIterations_;
    double expansionA_;
    PinIDs expansionPins_;
    void expand_();

    // Helpers
    double startingSurfaceArea_;
    double surface_area_();

    // Simulation World
    btBroadphaseInterface* worldBroadphase_;
    btDefaultCollisionConfiguration* worldCollisionConfig_;
    btCollisionDispatcher* worldCollisionDispatcher_;
    btSequentialImpulseConstraintSolver* worldConstraintSolver_;
    btSoftBodySolver* worldSoftBodySolver_;
    btSoftRigidDynamicsWorld* world_;
};
}
}

#endif  // VC_USE_BULLET
