//
// Created by Seth Parker on 7/26/16.
//

#define BOOST_TEST_MODULE AngleBasedFlattening

#include <boost/test/unit_test.hpp>
#include "core/shapes/Arch.h"
#include "core/shapes/Plane.h"
#include "core/vc_defines.h"
#include "testing/ParsingHelpers.h"
#include "testing/TestingUtils.h"
#include "texturing/AngleBasedFlattening.h"

using namespace volcart;

/***************************************************************************************
 *                                                                                     *
 *  abfTest.cpp - tests the functionality of /v-c/texturing/abf.cpp *
 *  The ultimate goal of this file is the following: *
 *                                                                                     *
 *    Confirm that the class produces UV coordinates that match expected output.
 * *
 *                                                                                     *
 *  This file is broken up into a test fixture which initializes the objects *
 *  used in each of the test cases. *
 *                                                                                     *
 *   1. PlaneABFUVTest *
 *   2. PlaneABFLSCMOnlyUVTest *
 *   3. ArchABFUVTest *
 *   4. ArchABFLSCMOnlyUVTest *
 *                                                                                     *
 * Input: *
 *     No required inputs for this sample test. All objects needed for the test
 * cases  *
 *     are constructed and destroyed by the fixtures. Note, we're only testing
 * the     *
 *     non-enclosed shapes here. Sphere, Cone and Cube have been omitted.
 * Pregenerated *
 *     test files were generated by vc_abfExample. *
 *                                                                                     *
 * Test-Specific Output: *
 *     Specific test output only given on failure of any tests. Otherwise,
 * general     *
 *     number of testing errors is output. *
 *                                                                                     *
 * *************************************************************************************/

/*
 *
 *    FIXTURES
 *
 */

struct CreatePlaneABFUVFixture {

    CreatePlaneABFUVFixture()
    {

        std::cerr << "Creating Plane UV map using ABF..." << std::endl;

        // Get ITK Mesh
        _in_Mesh = _Plane.itkMesh();

        // Create uvMap from mesh
        volcart::texturing::AngleBasedFlattening abf(_in_Mesh);
        abf.compute();
        _out_Mesh = abf.getMesh();

        // Load pre-generated output from file
        volcart::testing::ParsingHelpers::parseObjFile(
            "abf_Plane.obj", _SavedPoints, _SavedCells);
    }

    ~CreatePlaneABFUVFixture()
    {
        std::cerr << "Destroying Plane ABF UV map..." << std::endl;
    }

    // declare Plane mesh and width and height
    volcart::shapes::Plane _Plane;
    ITKMesh::Pointer _in_Mesh;
    ITKMesh::Pointer _out_Mesh;

    std::vector<Vertex> _SavedPoints;
    std::vector<Cell> _SavedCells;
};

struct CreatePlaneABFLSCMOnlyUVFixture {

    CreatePlaneABFLSCMOnlyUVFixture()
    {

        std::cerr << "Creating Plane UV map using ABF (LSCM only)..."
                  << std::endl;

        // Get ITK Mesh
        _in_Mesh = _Plane.itkMesh();

        // Create uvMap from mesh
        volcart::texturing::AngleBasedFlattening abf(_in_Mesh);
        abf.setUseABF(false);
        abf.compute();
        _out_Mesh = abf.getMesh();

        // Load pre-generated output from file
        volcart::testing::ParsingHelpers::parseObjFile(
            "abf_Plane_LSCMOnly.obj", _SavedPoints, _SavedCells);
    }

    ~CreatePlaneABFLSCMOnlyUVFixture()
    {
        std::cerr << "Destroying Plane ABF (LSCM only) UV map..." << std::endl;
    }

    // declare Plane mesh and width and height
    volcart::shapes::Plane _Plane;
    ITKMesh::Pointer _in_Mesh;
    ITKMesh::Pointer _out_Mesh;

    std::vector<Vertex> _SavedPoints;
    std::vector<Cell> _SavedCells;
};

struct CreateArchABFUVFixture {

    CreateArchABFUVFixture()
    {

        std::cerr << "Creating Arch UV map using ABF..." << std::endl;

        // get ITK Mesh
        _in_Mesh = _Arch.itkMesh();

        // Create uvMap from mesh
        volcart::texturing::AngleBasedFlattening abf(_in_Mesh);
        abf.compute();
        _out_Mesh = abf.getMesh();

        // Load pre-generated output from file
        volcart::testing::ParsingHelpers::parseObjFile(
            "abf_Arch.obj", _SavedPoints, _SavedCells);
    }

    ~CreateArchABFUVFixture()
    {
        std::cerr << "Destroying Arch ABF UV map..." << std::endl;
    }

    // declare Arch mesh
    volcart::shapes::Arch _Arch;
    ITKMesh::Pointer _in_Mesh;
    ITKMesh::Pointer _out_Mesh;

    std::vector<Vertex> _SavedPoints;
    std::vector<Cell> _SavedCells;
};

struct CreateArchABFLSCMOnlyUVFixture {

    CreateArchABFLSCMOnlyUVFixture()
    {

        std::cerr << "Creating Arch UV map using ABF (LSCM only)..."
                  << std::endl;

        // get ITK Mesh
        _in_Mesh = _Arch.itkMesh();

        // Create uvMap from mesh
        volcart::texturing::AngleBasedFlattening abf(_in_Mesh);
        abf.setUseABF(false);
        abf.compute();
        _out_Mesh = abf.getMesh();

        // Load pre-generated output from file
        volcart::testing::ParsingHelpers::parseObjFile(
            "abf_Arch_LSCMOnly.obj", _SavedPoints, _SavedCells);
    }

    ~CreateArchABFLSCMOnlyUVFixture()
    {
        std::cerr << "Destroying Arch ABF (LSCM only) UV map..." << std::endl;
    }

    // declare Arch mesh
    volcart::shapes::Arch _Arch;
    ITKMesh::Pointer _in_Mesh;
    ITKMesh::Pointer _out_Mesh;

    std::vector<Vertex> _SavedPoints;
    std::vector<Cell> _SavedCells;
};

/*
 *
 *    TEST CASES
 *
 */

BOOST_FIXTURE_TEST_CASE(PlaneABFUVTest, CreatePlaneABFUVFixture)
{

    // check size of uvMap and number of points in mesh
    BOOST_CHECK_EQUAL(
        _out_Mesh->GetNumberOfPoints(), _in_Mesh->GetNumberOfPoints());
    BOOST_CHECK_EQUAL(_out_Mesh->GetNumberOfPoints(), _SavedPoints.size());

    // check uvmap against original mesh input pointIDs
    for (size_t point = 0; point < _SavedPoints.size(); ++point) {

        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[0], _SavedPoints[point].x);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[1], _SavedPoints[point].y);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[2], _SavedPoints[point].z);
    }
}

BOOST_FIXTURE_TEST_CASE(PlaneABFLSCMOnlyUVTest, CreatePlaneABFLSCMOnlyUVFixture)
{

    // check size of uvMap and number of points in mesh
    BOOST_CHECK_EQUAL(
        _out_Mesh->GetNumberOfPoints(), _in_Mesh->GetNumberOfPoints());
    BOOST_CHECK_EQUAL(_out_Mesh->GetNumberOfPoints(), _SavedPoints.size());

    // check uvmap against original mesh input pointIDs
    for (size_t point = 0; point < _SavedPoints.size(); ++point) {

        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[0], _SavedPoints[point].x);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[1], _SavedPoints[point].y);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[2], _SavedPoints[point].z);
    }
}

BOOST_FIXTURE_TEST_CASE(ArchABFUVTest, CreateArchABFUVFixture)
{

    // check size of uvMap and number of points in mesh
    BOOST_CHECK_EQUAL(
        _out_Mesh->GetNumberOfPoints(), _in_Mesh->GetNumberOfPoints());
    BOOST_CHECK_EQUAL(_out_Mesh->GetNumberOfPoints(), _SavedPoints.size());

    // check uvmap against original mesh input pointIDs
    for (size_t point = 0; point < _SavedPoints.size(); ++point) {

        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[0], _SavedPoints[point].x);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[1], _SavedPoints[point].y);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[2], _SavedPoints[point].z);
    }
}

BOOST_FIXTURE_TEST_CASE(ArchABFLSCMOnlyUVTest, CreateArchABFLSCMOnlyUVFixture)
{

    // check size of uvMap and number of points in mesh
    BOOST_CHECK_EQUAL(
        _out_Mesh->GetNumberOfPoints(), _in_Mesh->GetNumberOfPoints());
    BOOST_CHECK_EQUAL(_out_Mesh->GetNumberOfPoints(), _SavedPoints.size());

    // check uvmap against original mesh input pointIDs
    for (size_t point = 0; point < _SavedPoints.size(); ++point) {

        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[0], _SavedPoints[point].x);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[1], _SavedPoints[point].y);
        volcart::testing::SmallOrClose(
            _out_Mesh->GetPoint(point)[2], _SavedPoints[point].z);
    }
}
