        // Output vertices
	std::cout << "Points = " << mesh->GetNumberOfPoints() << std::endl;
        typedef MeshType::PointsContainer::Iterator     PointsIterator;
        PointsIterator  pointIterator = mesh->GetPoints()->Begin();
        PointsIterator end = mesh->GetPoints()->End();
        while( pointIterator != end )
        {
                MeshType::PointType p = pointIterator.Value();  // access the point
                std::cout << p << std::endl;                    // print the point
                ++pointIterator;                                // advance to next point
        }
        typedef  MeshType::PointDataContainer::ConstIterator PointDataIterator;
        PointDataIterator pixelIterator = mesh->GetPointData()->Begin();
        PointDataIterator pixelEnd      = mesh->GetPointData()->End();
        while( pixelIterator != pixelEnd )
        {
                MeshType::PixelType pixel;
                pixel = pixelIterator.Value();
                std::cout << pixel << std::endl;
                ++pixelIterator;
        }

	// create line cell
	typedef itk::LineCell< CellType >         LineType;
        typedef CellType::CellAutoPointer         CellAutoPointer;
        CellAutoPointer line1;
        CellAutoPointer line2;
        CellAutoPointer line3;
	for ( int i = 0; i < numFaces; ++i ) {
                plyFile >> temp >> p1 >> p2 >> p3;

                /*line1.TakeOwnership(  new LineType  );
                line2.TakeOwnership(  new LineType  );
                line3.TakeOwnership(  new LineType  );
                
                line1->SetPointId( 0, p1 ); // line between points p1 and p2
                line1->SetPointId( 1, p2 );
                line2->SetPointId( 0, p2 ); // line between points p2 and p3
                line2->SetPointId( 1, p3 );
                line3->SetPointId( 0, p1 ); // line between points p1 and p3
                line3->SetPointId( 1, p3 );

                mesh->SetCell( i, line1 );
                mesh->SetCell( i+1, line2 );
                mesh->SetCell( i+2, line3 );
	}

	// output points in cell
        typedef CellType::PointIdIterator     PointsIterator;
        std::cout << "Cells  = " << mesh->GetNumberOfCells()  << std::endl;
        typedef MeshType::CellsContainer::Iterator  CellIterator;
        CellIterator  cellIterator = mesh->GetCells()->Begin();
        CellIterator  end          = mesh->GetCells()->End();
        while( cellIterator != end )
        {
                CellType * cell = cellIterator.Value();
                PointsIterator  pointsIterator = cell->PointIdsBegin();
                PointsIterator pointEnd = cell->PointIdsEnd();
                while( pointsIterator != pointEnd)
                {
                        std::cout << *pointsIterator << " ";
                        ++pointsIterator;
                }
                std::cout << std::endl;
                ++cellIterator;
        }

	// 1st attempt to generate 2D points, homography matrix only takes points of one triangle
	std::vector< cv::Vec3d > my3DPoints;    // 3D vector to hold 3D points
        std::vector< cv::Vec3d > my2DPoints;    // 3D vector to hold 2D points along with a 1 in the z coordinate
        cv::Vec3d my3DPoint;
        cv::Vec3d my2DPoint;
        //cv::Mat myH( 3, 3, CV_64F );          // homography matrix

        typedef MeshType::PointsContainer::Iterator     PointsIterator;
        PointsIterator  pointIterator = mesh->GetPoints()->Begin();
        PointsIterator end = mesh->GetPoints()->End();
        while( pointIterator != end )
        {
                MeshType::PointType p = pointIterator.Value();  // access the point
                my3DPoint = cv::Vec3d( p[0], p[1], p[2] );      // store point in opencv vec3d point
                my2DPoint = cv::Vec3d( p[0] / p[2], p[1] / p[2], 1 );   // calculate 2D point, u = x / z and v = y / z
                my3DPoints.push_back( my3DPoint );
                my2DPoints.push_back( my2DPoint );
                ++pointIterator;                                // advance to next point
        }
        std::cout << "3D size: " << my3DPoints.size() << " 2D size: " << my2DPoints.size() << std::endl;
        cv::Mat myH( 3, 3, CV_64F );            // homography matrix
        CalcHomographyFromPoints( my3DPoints, my2DPoints, myH );
